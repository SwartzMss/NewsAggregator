# 后端模块化设计（MVP，无鉴权）

> 目标：基于《DB_SCHEMA.md》的表结构，提供**可运行、可扩展**的后端服务；仅 HTTP 明文、无鉴权；满足前端「新增/管理 RSS、查看文章列表」。  
> **说明**：移除 `sources` 概念与相关接口；与来源相关的信息（如 `domain`、`display_name`）直接落在 `feeds` 与 `articles` 上。  
> **接口约定更新**：去除 `PATCH`，仅保留 `GET / POST / DELETE`。`POST /feeds` 采用 **upsert** 语义（存在即更新，不存在则创建）。

---

## 0. 技术栈与依赖（建议）
- 运行时：Rust + Tokio
- Web：Axum
- 数据库：SQLx（PostgreSQL）
- 抓取：Reqwest（`rustls`） + `rss` / `atom_syndication`
- 配置与日志：`serde` / `serde_yaml`、`tracing`
- 时间：`chrono`（统一 UTC）

**Cargo（关键）**
```
axum, tokio, sqlx = { features = ["runtime-tokio", "postgres", "chrono"] }
reqwest = { features = ["json", "gzip", "brotli", "deflate", "rustls-tls"] }
rss = "2"
serde, serde_json, serde_yaml, chrono, tracing, tracing-subscriber
```

---

## 1. 目录结构（模块拆分）
```
backend/
├─ Cargo.toml
├─ src/
│  ├─ main.rs
│  ├─ app.rs                    # AppState、路由装配、配置加载
│  ├─ config.rs                 # 配置结构/加载
│  ├─ api/                      # 控制器（路由处理）
│  │  ├─ mod.rs
│  │  ├─ health.rs              # GET /healthz
│  │  ├─ articles.rs            # GET /articles
│  │  └─ feeds.rs               # GET/POST/DELETE /feeds
│  ├─ service/                  # 业务服务层（组合仓库 + 规则）
│  │  ├─ mod.rs
│  │  ├─ articles.rs
│  │  └─ feeds.rs
│  ├─ repo/                     # 数据访问层（SQLx）
│  │  ├─ mod.rs
│  │  ├─ articles_repo.rs
│  │  └─ feeds_repo.rs
│  ├─ fetcher/                  # 抓取器（定时、并发、解析、写库）
│  │  ├─ mod.rs
│  │  ├─ scheduler.rs           # 轮询、并发控制
│  │  ├─ worker.rs              # 单 feed 拉取流程
│  │  └─ parse.rs               # RSS/Atom -> Article 映射
│  ├─ model/                    # DTO/实体（API 入出 & DB 行）
│  │  ├─ mod.rs
│  │  ├─ article.rs
│  │  └─ feed.rs
│  ├─ util/                     # 通用工具（时间/错误/分页/URL 规范化）
│  │  ├─ mod.rs
│  │  ├─ pagination.rs
│  │  ├─ time.rs
│  │  └─ urlnorm.rs
│  └─ error.rs                  # 统一错误类型到 HTTP 响应
├─ config/
│  ├─ config.example.yaml
│  └─ feeds.bootstrap.txt
└─ migrations/                  # sqlx migrate（建表 SQL，可选）
```

**分层说明**
- **API**：参数解析与响应封装；不写 SQL。  
- **Service**：组合 Repo 实现业务规则（无 Sources 关联）。  
- **Repo**：仅负责 SQL。  
- **Fetcher**：独立于 HTTP 路由运行。  

---

## 2. 配置（无鉴权）
`config/config.yaml`
```yaml
server:
  bind: "127.0.0.1:8080"

db:
  url: "postgres://user:pass@localhost:5432/news"

fetcher:
  interval_secs: 600
  concurrency: 8
  timeout_secs: 10

feeds:
  bootstrap_file: "config/feeds.bootstrap.txt"
```

---

## 3. 数据模型映射（与 DB 对齐｜无 Sources）

### 3.1 API 出参
```jsonc
// ArticleOut
{
  "id": 1001,
  "title": "Global markets rally...",
  "url": "https://...",
  "domain": "reuters.com",
  "display_name": "Reuters",
  "description": "Stocks rose...",
  "language": "en",
  "published_at": "2025-10-11T06:42:00Z"
}

// FeedOut
{
  "id": 10,
  "url": "https://www.reuters.com/world/rss",
  "title": "Reuters: World",
  "site_url": "https://www.reuters.com/world/",
  "domain": "reuters.com",
  "display_name": "Reuters",
  "language": "en",
  "country": null,
  "enabled": true,
  "fetch_interval_seconds": 600,
  "last_fetch_at": "2025-10-11T07:00:00Z",
  "last_fetch_status": 200,
  "fail_count": 0,
  "last_etag": "W/\"...\"",
  "last_modified": "Sat, 11 Oct 2025 07:00:00 GMT"
}
```

### 3.2 API 入参
```jsonc
// POST /feeds  （upsert 语义：存在即更新，不存在则创建）
{
  "url": "https://www.reuters.com/world/rss",
  "domain": "reuters.com",
  "display_name": "Reuters",
  "title": null,
  "site_url": null,
  "language": "en",
  "country": null,
  "enabled": true,
  "fetch_interval_seconds": 600
}
```

---

## 4. HTTP 接口（无鉴权｜仅 GET/POST/DELETE）

### 4.1 健康检查
- `GET /healthz` → `200 {"ok":true}`

### 4.2 文章列表
- `GET /articles`
  - 查询参数：`page`=1, `page_size`=20(≤50), `lang`, `domain`, `from`, `to`
  - 排序：`published_at DESC`
  - SQL（示意）：
    ```sql
    SELECT id, title, url, domain, display_name, description, language, published_at
    FROM news.articles
    WHERE ($1::text IS NULL OR language = $1)
      AND ($2::text IS NULL OR domain = $2)
      AND published_at BETWEEN $3 AND $4
    ORDER BY published_at DESC
    LIMIT $5 OFFSET $6;
    ```

### 4.3 Feeds（管理）
- `GET /feeds`：列表 + 状态字段  
- `POST /feeds`：**upsert**（新增或更新）  
- `DELETE /feeds/:id`：删除（可实现为物理删或将 `enabled=false`）  

> 若需要“只更新部分字段”，也通过 `POST /feeds` 提交“仅包含需要更新的字段”的 payload，服务端在 upsert 时进行**部分更新**。

---

## 5. 抓取器（Fetcher）设计

### 5.1 调度策略
- 每 `interval_secs` 轮询；并发度 `concurrency`  
- 仅抓取 `enabled=true` 的 feeds  
- 条件请求头：`If-None-Match`、`If-Modified-Since`  

### 5.2 单 Feed 流程（伪代码）
```
row = SELECT * FROM news.feeds WHERE id=?
resp = http.get(row.url, headers=conditional)

if 304:
  UPDATE feeds SET last_fetch_at=now(), last_fetch_status=304, fail_count=0 WHERE id=?
  return

if 200:
  items = parse(resp.body)
  for it in items:
    INSERT INTO news.articles (...,
      domain=row.domain,
      display_name=row.display_name,
      published_at=parsed_or_now(),
      fetched_at=now())
  UPDATE feeds SET
    last_fetch_at=now(),
    last_fetch_status=200,
    fail_count=0,
    last_etag=resp.etag?,
    last_modified=resp.last_modified?
  WHERE id=?
else:
  UPDATE feeds SET last_fetch_at=now(), last_fetch_status=resp.status, fail_count=fail_count+1 WHERE id=?
```

### 5.3 解析要点
- 字段：`title`、`link`、`description`  
- `published_at`：`pubDate` → `dc:date` → `updated` → `now()`  
- `language`：优先 item/频道；否则用 `feed.language`  

---

## 6. Service & Repo 主要函数（签名草案｜无 Sources）

### 6.1 Feeds
```rust
// repo/feeds_repo.rs
async fn upsert_feed(pool: &PgPool, data: FeedUpsert) -> Result<FeedRow>;
async fn list_feeds(pool: &PgPool, enabled: Option<bool>, page: i64, size: i64) -> Result<Vec<FeedRow>>;
async fn delete_feed(pool: &PgPool, id: i64) -> Result<()>;
async fn get_enabled_feeds(pool: &PgPool, limit: i64) -> Result<Vec<FeedRow>>;

// service/feeds.rs
async fn upsert(&self, payload: FeedUpsertPayload) -> Result<FeedOut>;
async fn list(&self, enabled: Option<bool>, page: i64, size: i64) -> Result<Vec<FeedOut>>;
async fn delete(&self, id: i64) -> Result<()>;
```

### 6.2 Articles
```rust
// repo/articles_repo.rs
async fn insert_article(pool: &PgPool, a: NewArticle) -> Result<i64>;
async fn list_articles(pool: &PgPool, q: ArticleListQuery) -> Result<(Vec<ArticleRow>, i64)>;

// service/articles.rs
async fn list(&self, q: ArticleListQuery) -> Result<Page<ArticleOut>>;
```

---

## 7. 错误与响应
- 统一错误结构：`{ "error": { "code": "BadRequest", "message": "..." } }`  
- 常见：400 参数缺失/非法；404 资源不存在；500 内部错误  
- Axum：为 `AppError` 实现 `IntoResponse`  

---

## 8. 性能与演进
- 索引：`articles(published_at DESC)`、可加 `articles(domain, published_at DESC)`  
- 连接池：SQLx `PgPool` → `max_connections`（10–20）  
- 抓取并发：`concurrency` 随网络调节  
- 演进：去重（`url_hash`）、检索（`pg_trgm`/全文）、留存清理/分区、鉴权（Token/OIDC）  

---

## 9. 启动顺序（开发）
1. 执行《DB_SCHEMA.md》
2. 准备 `config/config.yaml`（或 `DATABASE_URL`）  
3. `cargo run` 启动  
4. `GET /healthz`；`POST /feeds` 新增/更新 RSS；等待抓取后 `GET /articles` 验证数据  

---

## 10. 前端约定
- 全部 JSON，时间为 **UTC ISO8601**  
- 列表接口包含分页与 `total_hint`  
- 文章项至少包含：`title` / `url` / `domain` / `published_at`
